/*
 * This Kotlin source file was generated by the Gradle 'init' task.
 */
package io.lantern.observablemodel

import androidx.test.ext.junit.runners.AndroidJUnit4
import androidx.test.platform.app.InstrumentationRegistry
import org.junit.After
import org.junit.Assert.*
import org.junit.Before
import org.junit.Test
import org.junit.runner.RunWith
import java.io.IOException
import java.nio.file.*
import java.nio.file.attribute.BasicFileAttributes
import javax.crypto.KeyGenerator

@RunWith(AndroidJUnit4::class)
class AndroidObservableModelTest {
    private var tempDir: Path? = null

    @Test
    fun testQuery() {
        val model = buildModel()
        model.mutate { tx ->
            tx.putAll(
                mapOf(
                    "/contacts/32af234asdf324" to "That Person",
                    "/contacts/32af234asdf324/messages_by_timestamp/1" to "/messages/c",
                    "/contacts/32af234asdf324/messages_by_timestamp/2" to "/messages/a",
                    "/contacts/32af234asdf324/messages_by_timestamp/3" to "/messages/b",
                    "/contacts/32af234asdf324/messages_by_timestamp/4" to "/messages/e", // this one doesn't exist
                    "/messages/c" to "Message C",
                    "/messages/d" to "Message D", // this one isn't referenced by messages_by_timestamp
                    "/messages/a" to "Message A",
                    "/messages/b" to "Message B",
                )
            )
        }
        assertEquals("That Person", model.get("/contacts/32af234asdf324"))
        assertEquals("Message C", model.get("/messages/c"))
        assertEquals(
            arrayListOf(
                Entry("/messages/a", "Message A"),
                Entry("/messages/b", "Message B"),
                Entry("/messages/c", "Message C"),
                Entry("/messages/d", "Message D")
            ), model.list<String>("/messages/%")
        )
        assertEquals(
            arrayListOf(
                Detail(
                    "/contacts/32af234asdf324/messages_by_timestamp/3",
                    "/messages/b",
                    "Message B"
                ),
                Detail(
                    "/contacts/32af234asdf324/messages_by_timestamp/2",
                    "/messages/a",
                    "Message A"
                ),
                Detail(
                    "/contacts/32af234asdf324/messages_by_timestamp/1",
                    "/messages/c",
                    "Message C"
                ),
            ), model.listDetails<String>(
                "/contacts/32af234asdf324/messages_by_timestamp/%",
                0,
                10,
                reverseSort = true
            )
        )
        assertEquals(
            arrayListOf("Message C", "Message A", "Message B"),
            model.listDetails<String>("/contacts/32af234asdf324/messages_by_timestamp/%", 0, 10)
                .map { it.value }
        )
        assertEquals(
            arrayListOf("Message A"),
            model.listDetails<String>("/contacts/32af234asdf324/messages_by_timestamp/%", 1, 1)
                .map { it.value }
        )
        assertEquals(
            0,
            model.listDetails<String>(
                "/contacts/32af234asdf324/messages_by_timestamp/%",
                3,
                10
            ).size
        )
        model.close()
    }

    @Test
    fun testSubscribeDirectLate() {
        val model = buildModel()
        var theValue = "thevalue";

        model.mutate { tx ->
            tx.put("path", theValue)
        }
        model.subscribe(object : Subscriber<String>("100", "path") {
            override fun onUpdate(path: String, value: String) {
                assertEquals("path", path)
                assertEquals(theValue, value)
            }

            override fun onDelete(path: String) {
            }
        })

        theValue = "new value"
        model.mutate { tx ->
            tx.put("path", theValue)
        }
        model.close()
    }

    @Test
    fun testSubscribeDirect() {
        val model = buildModel()
        var currentValue = "original value";

        model.subscribe(object : Subscriber<String>("100", "path") {
            override fun onUpdate(path: String, value: String) {
                fail("this subscriber was replaced and should never have been notified")
            }

            override fun onDelete(path: String) {
            }
        })

        try {
            model.subscribe(object : Subscriber<String>("100", "path") {
                override fun onUpdate(path: String, value: String) {
                }

                override fun onDelete(path: String) {
                }
            })
            fail("re-registering already registered subscriber ID should not be allowed")
        } catch (e: IllegalArgumentException) {
            // expected
        }

        model.unsubscribe("100")

        model.subscribe(object : Subscriber<String>("100", "path") {
            override fun onUpdate(path: String, value: String) {
                assertEquals("path", path)
                // this subscriber should only ever get the original value because we unsubscribe later
                assertEquals("original value", value)
            }

            override fun onDelete(path: String) {
            }
        })

        var calledDelete = false

        model.subscribe(object : Subscriber<String>("101", "path") {
            override fun onUpdate(path: String, value: String) {
                assertEquals("path", path)
                // this subscriber should always get the current value becasue we don't unsubscribe it
                assertEquals(currentValue, value)
            }

            override fun onDelete(path: String) {
                assertEquals("path", path)
                calledDelete = true
            }
        })

        model.unsubscribe("100")

        model.mutate { tx ->
            tx.put("path", currentValue)
        }
        currentValue = "new value"
        model.mutate { tx ->
            tx.put("path", currentValue)
        }

        model.mutate { tx -> tx.delete("path") }
        assertTrue(calledDelete)

        model.close()
    }

    @Test
    fun testSubscribePrefixNoInit() {
        val model = buildModel()
        model.mutate { tx ->
            tx.putAll(
                mapOf(
                    "/path/1" to "1",
                    "/path/2" to "2",
                )
            )
        }

        var updateCalled = false
        var deleteCalled = false
        model.subscribe(object : Subscriber<String>("100", "/path") {
            override fun onUpdate(path: String, value: String) {
                assertEquals("/path/3", path)
                assertEquals("3", value)
                updateCalled = true
            }

            override fun onDelete(path: String) {
                assertEquals("/path/1", path)
                deleteCalled = true
            }
        }, receiveInitial = false)
        model.subscribe(object : Subscriber<String>("101", "/pa/") {
            override fun onUpdate(path: String, value: String) {
                fail("subscriber with no common prefix shouldn't get updates")
            }

            override fun onDelete(path: String) {
                fail("subscriber with no common prefix shouldn't get deletions")
            }
        }, receiveInitial = false)

        model.mutate { tx ->
            tx.delete("/path/1")
            tx.put("/path/3", "3")
        }

        assertTrue(updateCalled)
        assertTrue(deleteCalled)

        model.close()
    }

    @Test
    fun testSubscribePrefixInit() {
        val model = buildModel()
        model.mutate { tx ->
            tx.putAll(
                mapOf(
                    "/path/1" to "1",
                    "/path/2" to "2",
                    "/pa/1" to "1",
                )
            )
        }

        var updates = 0
        model.subscribe(object : Subscriber<String>("100", "/path") {
            override fun onUpdate(path: String, value: String) {
                assertTrue(path.startsWith("/path/"))
                assertEquals(path.substring(path.length - 1), value)
                updates += 1
            }

            override fun onDelete(path: String) {
            }
        })

        assertEquals(2, updates)
        model.close()
    }

    @Test
    fun testSubscribeDetailsPrefixInit() {
        val model = buildModel()
        model.mutate { tx ->
            tx.putAll(
                mapOf(
                    "/detail/1" to "1",
                    "/detail/2" to "2",
                    "/list/1" to "/detail/2",
                    "/list/2" to "/detail/1"
                )
            )
        }

        val updates = HashSet<Entry<String>>()
        val deletions = HashSet<String>()

        model.subscribeDetails(object : Subscriber<String>("100", "/list/") {
            override fun onUpdate(path: String, value: String) {
                updates.add(Entry(path, value))
            }

            override fun onDelete(path: String) {
                deletions.add(path)
            }
        })

        model.mutate { tx ->
            tx.put("/detail/1", "11")
            tx.put("/list/3", "/detail/3")
            tx.put("/detail/3", "3")
            tx.put("/list/4", "/detail/unknown") // since this doesn't have details, we shouldn't get notified about it
            tx.put("/detail/4", "4") // since this detail doesn't link back to a path in the list, we shouldn't get notified about it
        }

        model.mutate { tx ->
            tx.delete("/detail/2") // should show up as a deletion of /list/2
            tx.delete("/list/2")
        }

        assertEquals(setOf(
            Entry("/list/1", "2"),
            Entry("/list/2", "11"),
            Entry("/list/2", "1"),
            Entry("/list/3", "3"),
        ), updates)

        assertEquals(setOf("/list/1", "/list/2"), deletions)
        model.close()
    }

    @Test
    fun testDurability() {
        val model = buildModel()
        model.mutate { tx ->
            tx.putAll(mapOf("path1" to "value1", "path2" to "value2"))
        }

        try {
            model.mutate { tx ->
                tx.put("path3", "value3")
                throw Exception("I failed")
            }
        } catch (_: Throwable) {
            // ignore exception
        }
        model.close()

        // open the model again
        val model2 = buildModel()
        assertEquals("value1", model2.get<String>("path1"))
        assertEquals("value2", model2.get<String>("path2"))
        assertNull("path3 should have been rolled back", model2.get("path3"))
        model2.close()
    }

    private fun buildModel(): ObservableModel {
        val keyGenerator = KeyGenerator.getInstance("AES")
        keyGenerator.init(256)
        val key = keyGenerator.generateKey()
        return ObservableModel.build(
            InstrumentationRegistry.getInstrumentation().targetContext,
            filePath = Paths.get(
                tempDir.toString(),
                "testdb"
            ).toString(),
            password = "testpassword",
        )
    }

    @Before
    fun setupTempDir() {
        tempDir = Files.createTempDirectory("omtest")
    }

    @After
    fun deleteTempDir() {
        tempDir?.let {
            Files.walkFileTree(tempDir, object : FileVisitor<Path> {
                override fun preVisitDirectory(
                    dir: Path?,
                    attrs: BasicFileAttributes?
                ): FileVisitResult {
                    return FileVisitResult.CONTINUE;
                }

                override fun visitFile(file: Path?, attrs: BasicFileAttributes?): FileVisitResult {
                    Files.delete(file);
                    return FileVisitResult.CONTINUE;
                }

                override fun visitFileFailed(file: Path?, exc: IOException?): FileVisitResult {
                    return FileVisitResult.CONTINUE;
                }

                override fun postVisitDirectory(dir: Path?, exc: IOException?): FileVisitResult {
                    return FileVisitResult.CONTINUE;
                }
            })
        }
    }


//
//    @Test
//    fun testGetRangeDetails() {
//        val model = buildModel()
//        var theValue = listOf(1, 2, 3)
//        model.mutate { tx ->
//            tx.put("path", theValue)
//        }
//        model.mutate { tx ->
//            theValue.forEach {
//                tx.put("details/$it", "detail $it")
//            }
//        }
//        assertEquals(listOf("detail 2", "detail 3"), model.getRangeDetails<String>("path", "details", 1, 3))
//    }
//
//    @Test
//    fun testSubscribeDetails() {
//        val model = buildModel()
//        var theValue = listOf(1, 2, 3)
//        model.mutate { tx ->
//            tx.put("path", theValue)
//        }
//        model.mutate { tx ->
//            theValue.forEach { tx.put("details/$it", "detail $it") }
//        }
//
//        model.subscribeDetails<String>(100, "path", "details") { path: String, value: List ->
//            assertEquals("path", path)
//            assertEquals(theValue.map { "detail $it" }, value)
//            assertEquals(listOf("detail 2", "detail 3"), model.getRangeDetails<String>("path", "details", 1, 3))
//        }
//        model.close()
//    }
}
//
//class InMemoryObservableModelTest : ObservableModelTest() {
//    override fun buildModel(): ObservableModel {
//        return ObservableModel.build()
//    }
//}
//
//class EncryptedFileBasedObservableModelTest : ObservableModelTest() {
//
//
//}